;
; compile: nasm shellcode.asm
;
; NOTE: something to keep in mind when reading/editing this file is that we
; are executing this page out of write-combining memory. we regularly use
; sfence/wbinvd to try and flush things out and keep everything happy.
;
; otherwise, if you are not careful, there can be.. strange side effects.
;

BITS 32

;
; setup EBP to point at the base of this shellcode payload. this will allow
; us to easily make relative references to shellcode labels, making this
; payload position independent.
;

start:
        call    $+5
        pop     ebp
        sub     ebp, $-1

;
; check if we are the first thread to enter the ENDGAME shellcode page,
; if so, take the 'lock' to prevent the possibility of another thread
; coming through should we get preempted. this isn't totally out of the
; question since we sinkholed a page of kernel .text ...
;

check_lock:
        mov     eax, 0
        mov     ebx, 1
        lock cmpxchg [ebp+locked], ebx
        jz      repair_pte
.inf:
        hlt
        jmp     .inf ; trap any threads that could have chased us into this page

;
; repair the kernel .text PTE we corrupted to hijack code execution. please
; note that this must reconcile with the address/values in main.py
;

repair_pte:
        mov     eax, 0xc0200088
        mov     dword [eax], 0x22461
        invlpg  [0x80022000]
        wbinv

;
; dynamically resolve kernel exports that the shellcode will use
;

locate_exports:
        cld                          ; clear the direction flag so the string instructions increment the address
        mov     esi, 80010000h       ; kernel base address
        mov     eax, [esi+3Ch]       ; value of e_lfanew (File address of new exe header)
        mov     ebx, [esi+eax+78h]   ; value of IMAGE_NT_HEADERS32 -> IMAGE_OPTIONAL_HEADER32 -> IMAGE_DATA_DIRECTORY -> ibo32 (Virtual Address) (0x02e0)
        add     ebx, esi
        mov     edx, [ebx+1Ch]       ; value of IMAGE_DIRECTORY_ENTRY_EXPORT -> AddressOfFunctions (0x0308)
        add     edx, esi             ; address of kernel export table
        lea     edi, [ebp+kexports]  ; address of the local kernel export table

.get_exports:
        mov     ecx, [edi]           ; load the entry from the local table
        jecxz   .done_exports
        sub     ecx, [ebx+10h]       ; subtract the IMAGE_DIRECTORY_ENTRY_EXPORT -> Base
        mov     eax, [edx+4*ecx]     ; load the export by number from the kernel table
        test    eax, eax
        jz      .empty               ; skip if the export is empty
        add     eax, esi             ; add kernel base address to the export to construct a valid pointer

.empty:
        stosd                        ; save the value back to the local table and increment EDI by 4
        jmp    .get_exports

.done_exports:

;
; find XAPI's CopyFile() - "55 [8D 6C 24 A0 81 EC 9C 00] ..."
;

find_copy_file:
        mov     ecx, 0x30000        ; approximate memory address in the dash to start searching forward from
        mov     edx, 0xA0000        ; approximate memory address in the dash to stop searching

.check_pattern:
        inc     ecx                 ; increment the search pointer
        cmp     ecx, edx            ; compare current address with end address
        jge     .error              ; if past the end of the search space, end the search

        mov     eax, [ecx]          ; move 4 bytes from the current address (dash code) into EAX
        cmp     eax, 0xa0246c8d     ; compare with the first part of the egg (reversed due to endianness)
        jnz     .check_pattern      ; if not equal, continue searching

        mov     eax, [ecx+4]        ; move the next 4 bytes from memory into EAX
        cmp     eax, 0x009cec81     ; compare with the second part of the egg (reversed due to endianness)
        jnz     .check_pattern      ; if not equal, continue searching

        dec     ecx                 ; found it! decrement ECX since the pattern is +1 into the func
        lea     edi, [ebp+CopyFileEx]
        mov     [edi], ecx
        jmp     .done_resolution

.error:
        jmp     .error

.done_resolution:
        wbinvd

;
; drop IRQL to PASSIVE because the thread we hijacked may have come in at a
; higher level and this can cause issues when calling kernel exports or XAPI
;

lower_irql:
        mov     ecx, 0
        call    dword [ebp+KfLowerIrql]

%ifdef DEBUG

;
; locate the of address our 'helper' allocation in memory. this is purely
; used for debug / testing of ENDGAME -- it helped provide some introspection
; on where our stuff was getting mapped on retail hardware.
;

find_helper:
        mov     ebx, 0xF1000000         ; where to start searching memory

.loop:
        add     ebx, 0x1000             ; increment to the next page

        push    ebx
        call    [ebp+MmIsAddressValid]  ; check if the address is safe to dereference
        jz      .loop

        cmp     dword [ebx], 0x71615141 ; does this page start with our magic marker?
        jnz     .loop

dbg_print:

;
; sprintf(...)
;

        sub     esp, 0x100              ; make a 256 byte buffer on the stack
        mov     ecx, esp
        push    ebx                     ; arg1 for format string
        lea     eax, [ebp+fmt_str]
        push    eax                     ; format string
        push    ecx                     ; buffer
        sfence
        call    [ebp+sprintf]
        add     esp, 0x0C

;
; OutputDebugString(...)
;

        push    esp                  ; Buffer
        push    0
        mov     word [esp+0], ax     ; Length
        mov     word [esp+2], 0x100  ; MaxLength
        sfence

        mov     ecx, esp
        mov     eax, 1
        int     0x2D                 ; debug print to superio
        int3                         ; do not remove (required for proper int 2Dh handling)

        add     esp, 0x108           ; cleanup buffer (0x100) + debug print structure (0x8)

%endif

;
; loop through each memory card drive letter and attempt to copy payload.xbe
; from the MU to E:\payload.xbe. Once a copy succeeds, break from the loop.
;

copy_file:
        cmp     byte [ebp+mu_path], 'N' ; have we made it through all the memory card slots?
        je      copy_failure

        xor     eax, eax
        push    eax                     ; - dwCopyFlags
        push    eax                     ; - pbCancel
        push    eax                     ; - lpData
        push    eax                     ; - lpProgressRoutine
        lea     eax, [ebp+hdd_path]
        push    eax                     ; - lpNewFileName
        lea     eax, [ebp+mu_path]
        push    eax                     ; - lpExistingFilename
        call    dword [ebp+CopyFileEx]  ; CopyFileEx(MU_X, HDD, NULL, NULL, NULL, NULL);

        inc     byte [ebp+mu_path]      ; increment drive letter to try copying from the next MU
        %ifdef DUMP                     ; do the same for the dump files
        inc     byte [ebp+eeprom_path+4]
        inc     byte [ebp+bios_path+4]
        %endif
        wbinvd

        test    eax, eax                ; if CopyFileEx(...) did not indicate it copied a file, keep looping
        jz      copy_file

copy_success:
        mov     ecx, 0D7h               ; red-orange-green (success)
        lea     eax, [ebp+blink_led]
        call    eax
        jmp     make_habibi

copy_failure:
        mov     ecx, 0A0h               ; red blinking (failure)
        call    blink_led
.inf:
        jmp     short .inf

;
; modify the RSA key data to make it habibi compatible
;

make_habibi:

%ifdef DUMP

;
; dump eeprom and bios image to MU
;

dump_info:

        ; disable write protection
        ;mov     eax, cr0
        ;and     eax, 0FFFEFFFFh
        ;mov     cr0, eax

        ; prologue
        push    esp
        mov     ebx, esp             ; temp stack frame
        sub     esp, 0200h

        ; dump eeprom
        lea     eax, [ebx-8]         ; &ResultLength
        push    eax
        push    256                  ; sizeof(eeprom)
        lea     eax, [ebx-0108h]     ; &eeprom
        push    eax
        lea     eax, [ebx-4]         ; &dwType
        push    eax
        push    0FFFFh               ; XC_MAX_ALL
        call    [ebp+ExQueryNonVolatileSetting] ; ExQueryNonVolatileSetting(XC_MAX_ALL, &dwType, &eeprom, sizeof(eeprom), &ResultLength);
        test    eax, eax
        jnz     $               ; spin on failure

        ; save eeprom
        push    256
        lea     eax, [ebx-0108h]
        push    eax
        lea     eax, [ebp+eeprom_path]
        push    eax
        call    write_file      ; (char* file_path, void* data, int size)

        ; copy bios image from FLASH to RAM (required by NtWriteFile)
        ; TODO: grab actual bios size so we don't have to dedupe client-side for images smaller than 1MB
        push    1024 * 1024
        call    dword [ebp+MmAllocateContiguousMemory]
        test    eax, eax
        jz      $               ; spin on failure
        mov     esi, 0FF000000h
        mov     edi, eax
        mov     ecx, 1024 * 1024
        rep     movsb

        ; save bios
        push    1024 * 1024
        push    eax
        lea     eax, [ebp+bios_path]
        push    eax
        call    write_file      ; (char* file_path, void* data, int size)

        ; epilogue
        mov     esp, ebx
        pop     ebx

%endif

        mov     ebx, [ebp+XePublicKeyData]
        or      ebx, 0xF0000000
        pushf
        cli                                 ; disable interrupts
        xor     dword [ebx+110h], 2DD78BD6h ; alter the last 4 bytes of the public key
        mov     ecx, cr3                    ; invalidate TLB
        mov     cr3, ecx
        popf                                ; re-enable interrupts

;
; cribbed from past softmods, roughly a re-creation of the following:
;  - https://github.com/XboxDev/OpenXDK/blob/master/src/hal/xbox.c#L36
;

launch_xbe:
        mov     esi, [ebp+LaunchDataPage]              ; https://xboxdevwiki.net/Kernel/LaunchDataPage
        mov     ebx, [esi]
        mov     edi, 1000h
        test    ebx, ebx                               ; check the LaunchDataPage pointer
        jnz     .mem_ok                                ; jump if it's not NULL
        push    edi
        call    dword [ebp+MmAllocateContiguousMemory] ; otherwise, allocate a memory page
        mov     ebx, eax                               ; and store the pointer to the allocated page in EBX
        mov     [esi], eax                             ; store the pointer back to the kernel as well

.mem_ok:
        push    byte 1
        push    edi
        push    ebx
        call    dword [ebp+MmPersistContiguousMemory]

        mov     edi,ebx
        xor     eax,eax
        mov     ecx,400h
        rep     stosd                   ; fill the whole LaunchDataPage memory page (4096 Bytes) with zeros

        or      dword [ebx], byte -1    ; set LaunchDataPage.launch_data_type to 0xFFFFFFFF
        mov     [ebx+4], eax            ; set LaunchDataPage.title_id to 0
        lea     edi, [ebx+8]            ; copy the address of LaunchDataPage.launch_path string
        lea     esi, [ebp+xbe_str]
        push    byte xbe_strlen
        pop     ecx
        rep     movsb                   ; copy the executable path to the LaunchDataPage.launch_path
        push    byte 2                  ; 2 stands for ReturnFirmwareQuickReboot
        sfence
        wbinvd                          ; flush the CPU caches to ensure all our writes are in main memory
        call    dword [ebp+HalReturnToFirmware]

.inf:
        jmp     short .inf

;
; blink LED to demonstrate code execution
;

blink_led:
        push    ecx
        push    byte 0
        push    byte 8
        push    byte 20h
        call    [ebp+HalWriteSMBusValue] ; set LED pattern

        push    byte 1
        push    byte 0
        push    byte 7
        push    byte 20h
        call    [ebp+HalWriteSMBusValue] ; enable LED override

        ret

%ifdef DUMP

write_file:     ; (char* file_path, void* data, int size)
        push    ebx                     ; modified base frame pointer
        mov     ebx, esp
        sub     esp, 0200h
        ; [ebx-20h] = pansi string
        ; [ebx-18h] = object attributes
        ; [ebx-0Ch] = status block
        ; [ebx-4] = handle
        ; [ebx+8] = file_path
        ; [ebx+0Ch] = data
        ; [ebx+10h] = size

        ;PANSI_STRING:
        ;	dw	0               ; USHORT Length
        ;	dw	0               ; USHORT MaximumLength
        ;	dd	str_ptr         ; PCHAR Buffer
        ;OBJECT_ATTRIBUTES:
        ;	dd	0		; HANDLE RootDirectory
        ;	dd	ansi_str_ptr    ; PANSI_STRING ObjectName
        ;	dd	00000040h	; ULONG Attributes (OBJ_CASE_INSENSITIVE)
        ;IO_STATUS_BLOCK:
        ;	dd	0
        ;	dd	0
        ;HANDLE:
        ;	dd	0

        ; build ansi string
        push    dword [ebx+8]
        lea     eax, [ebx-0x20]
        push    eax
        call    [ebp+RtlInitAnsiString]         ; RtlInitAnsiString(destination, source)
        test    eax, eax
        jnz     $                               ; spin on failure

        ; build object Attributes
        mov     dword [ebx-018h], 0
        lea     eax, [ebx-0x20]
        mov     dword [ebx-014h], eax
        mov     dword [ebx-010h], 040h

        ; create file
        push    000000060h                      ; CreateOptions (FILE_SYNCHRONOUS_IO_NONALERT + FILE_NON_DIRECTORY_FILE)
        push    000000005h                      ; CreateDisposition (FILE_OVERWRITE_IF)
        push    000000001h                      ; ShareAccess (FILE_SHARE_READ)
        push    000000080h                      ; FileAttributes (FILE_ATTRIBUTE_NORMAL)
        push    0                               ; AllocationSize (NULL)
        lea     eax, [ebx-0Ch]                  ; IOStatusBlock address
        push    eax
        lea     eax, [ebx-018h]                 ; ObjectAttributes address
        push    eax
        push    0C0000000h                      ; DesiredAccess (GENERIC_WRITE + GENERIC_READ)
        lea     eax, [ebx-4]                    ; FileHandle address
        push    eax
        call    [ebp+NtCreateFile]
        test    eax, eax
        jnz     $                               ; spin on failure

        ; write the data
        push    0                               ; ByteOffset (NULL)
        push    dword [ebx+10h]                 ; Length
        push    dword [ebx+0Ch]                 ; buffer address
        lea     eax, [ebx-0xC]                  ; loads IOStatusBlock address
        push    eax                             ; IOStatusBlock
        push    0                               ; ApcContext (NULL)
        push    0                               ; ApcRoutine (NULL)
        push    0                               ; Event (NULL)
        push    dword [ebx-4]                   ; FileHandle
        call    [ebp+NtWriteFile]
        test    eax, eax
        jnz     $                               ; spin on failure

        ; close the file
        push    dword [ebx-4]                   ; FileHandle
        call    [ebp+NtClose]                   ; calls NtClose
        test    eax, eax
        jnz     $                               ; spin on failure

        mov     esp, ebx
        pop     ebx
        ret
%endif

;
; '.data' section for our shellcode
;

kexports:
HalReturnToFirmware         dd 49
HalWriteSMBusValue          dd 50
KfLowerIrql                 dd 161
LaunchDataPage              dd 164
MmAllocateContiguousMemory  dd 165
MmPersistContiguousMemory   dd 178
XePublicKeyData             dd 355

; ENDGAME debug helpers
%ifdef DEBUG
MmIsAddressValid            dd 174
sprintf                     dd 362
%endif

; ENDGAME dump helpers
%ifdef DUMP
ExQueryNonVolatileSetting   dd 24
NtClose                     dd 187
NtCreateFile                dd 190
NtWriteFile                 dd 236
RtlInitAnsiString           dd 289
%endif

; end of local export table
                            dd 0

xapi:
CopyFileEx                  dd 0

strings:
mu_path                     db 'F:\payload.xbe', 0 ; first memory card slot
hdd_path                    db 'C:\payload.xbe', 0 ; E drive (as aliased in dash)
xbe_str                     db '\Device\Harddisk0\Partition1\payload.xbe', 0
xbe_strlen                  equ $-xbe_str

%ifdef DEBUG
fmt_str                     db 'Spray base 0x%08X', 0x0a, 0x0d, 0
%endif

%ifdef DUMP
eeprom_path                 db '\??\E:\eeprom.bin', 0
bios_path                   db '\??\E:\bios.bin', 0
%endif

misc:
locked                      dd 0
version                     dd 0x00010000 ; [-unused-].[major].[minor].[patch]

;
; no purpose but to serve as a static marker for the end of our shellcode
;

end:
                            dd 0xCCCCCCCC